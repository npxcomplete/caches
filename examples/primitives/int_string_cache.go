// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package primitives

type iIntString_NODE struct {
	next *iIntString_NODE
	prev *iIntString_NODE

	key   int
	value string
}

type iIntStringLRU struct {
	// add to head
	head *iIntString_NODE

	// fast access
	store map[int]*iIntString_NODE

	// full if stack == nil
	stack *iIntString_NODE

	// v_node pool, to prevent GC churn
	nodes []iIntString_NODE
}

func NewIntStringLRU(capacity int) *iIntStringLRU {
	memoryPool := make([]iIntString_NODE, capacity)
	for i := 0; i < capacity-1; i++ {
		memoryPool[i].next = &memoryPool[i+1]
	}

	// simplified nil checks
	dummy := &iIntString_NODE{}

	dummy.next = dummy
	dummy.prev = dummy

	return &iIntStringLRU{
		store: make(map[int]*iIntString_NODE),
		stack: &memoryPool[0],
		head:  dummy,
		nodes: memoryPool,
	}
}

func (lru *iIntStringLRU) Put(key int, value string) (evictedValue string) {
	var node *iIntString_NODE = nil
	var ok bool

	if node, ok = lru.store[key]; ok {
		// key already present, evict present node to replace
	} else if lru.stack == nil {
		// cache full, evict the tail
		node = lru.head.prev
	}

	// do eviction
	if node != nil {
		node.prev.next = node.next
		node.next.prev = node.prev

		node.prev = nil
		node.next = nil

		// stack push
		node.next = lru.stack
		lru.stack = node

		evictedValue = node.value
		delete(lru.store, node.key)
	}

	// stack must be non-empty by now
	node = lru.stack
	lru.stack = lru.stack.next

	node.key = key
	node.value = value

	// insert at head
	node.next = lru.head.next
	node.next.prev = node
	node.prev = lru.head
	lru.head.next = node

	lru.store[key] = node

	return
}

func (lru *iIntStringLRU) Get(key int) (value string, err error) {
	var node *iIntString_NODE
	var ok bool
	if node, ok = lru.store[key]; !ok {
		err = MissingValueError
		return
	}

	value = node.value
	// Put implicitly resets eviction priority
	lru.Put(key, value)
	return
}
